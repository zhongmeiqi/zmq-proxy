// This file is auto generated by the protocol-buffers compiler

/* eslint-disable quotes */
/* eslint-disable indent */
/* eslint-disable no-redeclare */
/* eslint-disable camelcase */

// Remember to `npm install --save ../../protocol-buffers-encodings`
import * as encodings from "./protocol-buffers-encodings.js";
var varint = encodings.varint;
var skip = encodings.skip;

export const CProto_notice_mixed_push = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null,
};

export const Cproto_notice_push_detail = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null,
};

export const Cproto_data_change_event = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null,
};

export const CProto_notice_push = {
  buffer: true,
  encodingLength: null,
  encode: null,
  decode: null,
};

defineCProto_notice_mixed_push();
defineCproto_notice_push_detail();
defineCproto_data_change_event();
defineCProto_notice_push();

function defineCProto_notice_mixed_push() {
  var enc = [encodings.string, CProto_notice_push, encodings.int32];

  CProto_notice_mixed_push.encodingLength = encodingLength;
  CProto_notice_mixed_push.encode = encode;
  CProto_notice_mixed_push.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (defined(obj.topic)) {
      var len = enc[0].encodingLength(obj.topic);
      length += 1 + len;
    }
    if (defined(obj.notice_push_list)) {
      for (var i = 0; i < obj.notice_push_list.length; i++) {
        if (!defined(obj.notice_push_list[i])) continue;
        var len = enc[1].encodingLength(obj.notice_push_list[i]);
        length += varint.encodingLength(len);
        length += 1 + len;
      }
    }
    if (defined(obj.msgcnt)) {
      var len = enc[2].encodingLength(obj.msgcnt);
      length += 1 + len;
    }
    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (defined(obj.topic)) {
      buf[offset++] = 10;
      enc[0].encode(obj.topic, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.notice_push_list)) {
      for (var i = 0; i < obj.notice_push_list.length; i++) {
        if (!defined(obj.notice_push_list[i])) continue;
        buf[offset++] = 18;
        varint.encode(
          enc[1].encodingLength(obj.notice_push_list[i]),
          buf,
          offset
        );
        offset += varint.encode.bytes;
        enc[1].encode(obj.notice_push_list[i], buf, offset);
        offset += enc[1].encode.bytes;
      }
    }
    if (defined(obj.msgcnt)) {
      buf[offset++] = 24;
      enc[2].encode(obj.msgcnt, buf, offset);
      offset += enc[2].encode.bytes;
    }
    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length))
      throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      topic: "",
      notice_push_list: [],
      msgcnt: 0,
    };
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset;
        return obj;
      }
      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;
      switch (tag) {
        case 1:
          obj.topic = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 2:
          var len = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          obj.notice_push_list.push(enc[1].decode(buf, offset, offset + len));
          offset += enc[1].decode.bytes;
          break;
        case 3:
          obj.msgcnt = enc[2].decode(buf, offset);
          offset += enc[2].decode.bytes;
          break;
        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineCproto_notice_push_detail() {
  var enc = [
    encodings.int32,
    encodings.string,
    encodings.int64,
    encodings.double,
  ];

  Cproto_notice_push_detail.encodingLength = encodingLength;
  Cproto_notice_push_detail.encode = encode;
  Cproto_notice_push_detail.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (defined(obj.directoperid)) {
      var len = enc[0].encodingLength(obj.directoperid);
      length += 1 + len;
    }
    if (defined(obj.fundid)) {
      var len = enc[0].encodingLength(obj.fundid);
      length += 1 + len;
    }
    if (defined(obj.projectid)) {
      var len = enc[0].encodingLength(obj.projectid);
      length += 1 + len;
    }
    if (defined(obj.stkcode)) {
      var len = enc[1].encodingLength(obj.stkcode);
      length += 1 + len;
    }
    if (defined(obj.stkname)) {
      var len = enc[1].encodingLength(obj.stkname);
      length += 1 + len;
    }
    if (defined(obj.market)) {
      var len = enc[1].encodingLength(obj.market);
      length += 1 + len;
    }
    if (defined(obj.bsflag)) {
      var len = enc[1].encodingLength(obj.bsflag);
      length += 1 + len;
    }
    if (defined(obj.bsname)) {
      var len = enc[1].encodingLength(obj.bsname);
      length += 1 + len;
    }
    if (defined(obj.instrsno)) {
      var len = enc[2].encodingLength(obj.instrsno);
      length += 1 + len;
    }
    if (defined(obj.instrsnomodi)) {
      var len = enc[0].encodingLength(obj.instrsnomodi);
      length += 1 + len;
    }
    if (defined(obj.instrqty)) {
      var len = enc[3].encodingLength(obj.instrqty);
      length += 1 + len;
    }
    if (defined(obj.instrprice)) {
      var len = enc[3].encodingLength(obj.instrprice);
      length += 1 + len;
    }
    if (defined(obj.title)) {
      var len = enc[1].encodingLength(obj.title);
      length += 1 + len;
    }
    if (defined(obj.remark)) {
      var len = enc[1].encodingLength(obj.remark);
      length += 1 + len;
    }
    if (defined(obj.topic)) {
      var len = enc[1].encodingLength(obj.topic);
      length += 1 + len;
    }
    if (defined(obj.msubtype)) {
      var len = enc[1].encodingLength(obj.msubtype);
      length += 2 + len;
    }
    if (defined(obj.receiver)) {
      var len = enc[1].encodingLength(obj.receiver);
      length += 2 + len;
    }
    if (defined(obj.style)) {
      var len = enc[1].encodingLength(obj.style);
      length += 2 + len;
    }
    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (defined(obj.directoperid)) {
      buf[offset++] = 8;
      enc[0].encode(obj.directoperid, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.fundid)) {
      buf[offset++] = 16;
      enc[0].encode(obj.fundid, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.projectid)) {
      buf[offset++] = 24;
      enc[0].encode(obj.projectid, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.stkcode)) {
      buf[offset++] = 34;
      enc[1].encode(obj.stkcode, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.stkname)) {
      buf[offset++] = 42;
      enc[1].encode(obj.stkname, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.market)) {
      buf[offset++] = 50;
      enc[1].encode(obj.market, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.bsflag)) {
      buf[offset++] = 58;
      enc[1].encode(obj.bsflag, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.bsname)) {
      buf[offset++] = 66;
      enc[1].encode(obj.bsname, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.instrsno)) {
      buf[offset++] = 72;
      enc[2].encode(obj.instrsno, buf, offset);
      offset += enc[2].encode.bytes;
    }
    if (defined(obj.instrsnomodi)) {
      buf[offset++] = 80;
      enc[0].encode(obj.instrsnomodi, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.instrqty)) {
      buf[offset++] = 89;
      enc[3].encode(obj.instrqty, buf, offset);
      offset += enc[3].encode.bytes;
    }
    if (defined(obj.instrprice)) {
      buf[offset++] = 97;
      enc[3].encode(obj.instrprice, buf, offset);
      offset += enc[3].encode.bytes;
    }
    if (defined(obj.title)) {
      buf[offset++] = 106;
      enc[1].encode(obj.title, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.remark)) {
      buf[offset++] = 114;
      enc[1].encode(obj.remark, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.topic)) {
      buf[offset++] = 122;
      enc[1].encode(obj.topic, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.msubtype)) {
      buf[offset++] = 130;
      buf[offset++] = 1;
      enc[1].encode(obj.msubtype, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.receiver)) {
      buf[offset++] = 138;
      buf[offset++] = 1;
      enc[1].encode(obj.receiver, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.style)) {
      buf[offset++] = 146;
      buf[offset++] = 1;
      enc[1].encode(obj.style, buf, offset);
      offset += enc[1].encode.bytes;
    }
    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length))
      throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      directoperid: 0,
      fundid: 0,
      projectid: 0,
      stkcode: "",
      stkname: "",
      market: "",
      bsflag: "",
      bsname: "",
      instrsno: 0,
      instrsnomodi: 0,
      instrqty: 0,
      instrprice: 0,
      title: "",
      remark: "",
      topic: "",
      msubtype: "",
      receiver: "",
      style: "",
    };
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset;
        return obj;
      }
      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;
      switch (tag) {
        case 1:
          obj.directoperid = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 2:
          obj.fundid = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 3:
          obj.projectid = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 4:
          obj.stkcode = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 5:
          obj.stkname = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 6:
          obj.market = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 7:
          obj.bsflag = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 8:
          obj.bsname = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 9:
          obj.instrsno = enc[2].decode(buf, offset);
          offset += enc[2].decode.bytes;
          break;
        case 10:
          obj.instrsnomodi = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 11:
          obj.instrqty = enc[3].decode(buf, offset);
          offset += enc[3].decode.bytes;
          break;
        case 12:
          obj.instrprice = enc[3].decode(buf, offset);
          offset += enc[3].decode.bytes;
          break;
        case 13:
          obj.title = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 14:
          obj.remark = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 15:
          obj.topic = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 16:
          obj.msubtype = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 17:
          obj.receiver = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 18:
          obj.style = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineCproto_data_change_event() {
  var enc = [encodings.string, encodings.int32];

  Cproto_data_change_event.encodingLength = encodingLength;
  Cproto_data_change_event.encode = encode;
  Cproto_data_change_event.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (defined(obj.event_name)) {
      var len = enc[0].encodingLength(obj.event_name);
      length += 1 + len;
    }
    if (defined(obj.funcid)) {
      var len = enc[1].encodingLength(obj.funcid);
      length += 1 + len;
    }
    if (defined(obj.event_time)) {
      var len = enc[1].encodingLength(obj.event_time);
      length += 1 + len;
    }
    if (defined(obj.fundid)) {
      var len = enc[1].encodingLength(obj.fundid);
      length += 1 + len;
    }
    if (defined(obj.projectid)) {
      var len = enc[1].encodingLength(obj.projectid);
      length += 1 + len;
    }
    if (defined(obj.fundacct)) {
      var len = enc[0].encodingLength(obj.fundacct);
      length += 1 + len;
    }
    if (defined(obj.remark)) {
      var len = enc[0].encodingLength(obj.remark);
      length += 1 + len;
    }
    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (defined(obj.event_name)) {
      buf[offset++] = 10;
      enc[0].encode(obj.event_name, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.funcid)) {
      buf[offset++] = 16;
      enc[1].encode(obj.funcid, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.event_time)) {
      buf[offset++] = 24;
      enc[1].encode(obj.event_time, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.fundid)) {
      buf[offset++] = 32;
      enc[1].encode(obj.fundid, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.projectid)) {
      buf[offset++] = 40;
      enc[1].encode(obj.projectid, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.fundacct)) {
      buf[offset++] = 50;
      enc[0].encode(obj.fundacct, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.remark)) {
      buf[offset++] = 58;
      enc[0].encode(obj.remark, buf, offset);
      offset += enc[0].encode.bytes;
    }
    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length))
      throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      event_name: "",
      funcid: 0,
      event_time: 0,
      fundid: 0,
      projectid: 0,
      fundacct: "",
      remark: "",
    };
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset;
        return obj;
      }
      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;
      switch (tag) {
        case 1:
          obj.event_name = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 2:
          obj.funcid = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 3:
          obj.event_time = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 4:
          obj.fundid = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 5:
          obj.projectid = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 6:
          obj.fundacct = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 7:
          obj.remark = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defineCProto_notice_push() {
  var enc = [
    encodings.string,
    encodings.int32,
    Cproto_notice_push_detail,
    Cproto_data_change_event,
  ];

  CProto_notice_push.encodingLength = encodingLength;
  CProto_notice_push.encode = encode;
  CProto_notice_push.decode = decode;

  function encodingLength(obj) {
    var length = 0;
    if (defined(obj.topic)) {
      var len = enc[0].encodingLength(obj.topic);
      length += 1 + len;
    }
    if (defined(obj.mid)) {
      var len = enc[0].encodingLength(obj.mid);
      length += 1 + len;
    }
    if (defined(obj.mtime)) {
      var len = enc[0].encodingLength(obj.mtime);
      length += 1 + len;
    }
    if (defined(obj.mtype)) {
      var len = enc[0].encodingLength(obj.mtype);
      length += 1 + len;
    }
    if (defined(obj.subid)) {
      var len = enc[1].encodingLength(obj.subid);
      length += 1 + len;
    }
    if (defined(obj.msgcnt)) {
      var len = enc[1].encodingLength(obj.msgcnt);
      length += 1 + len;
    }
    if (defined(obj.mpoint)) {
      var len = enc[0].encodingLength(obj.mpoint);
      length += 1 + len;
    }
    if (defined(obj.msubtype)) {
      var len = enc[0].encodingLength(obj.msubtype);
      length += 1 + len;
    }
    if (defined(obj.notice_push_list)) {
      for (var i = 0; i < obj.notice_push_list.length; i++) {
        if (!defined(obj.notice_push_list[i])) continue;
        var len = enc[2].encodingLength(obj.notice_push_list[i]);
        length += varint.encodingLength(len);
        length += 1 + len;
      }
    }
    if (defined(obj.data_change_event_list)) {
      for (var i = 0; i < obj.data_change_event_list.length; i++) {
        if (!defined(obj.data_change_event_list[i])) continue;
        var len = enc[3].encodingLength(obj.data_change_event_list[i]);
        length += varint.encodingLength(len);
        length += 1 + len;
      }
    }
    return length;
  }

  function encode(obj, buf, offset) {
    if (!offset) offset = 0;
    if (!buf) buf = Buffer.allocUnsafe(encodingLength(obj));
    var oldOffset = offset;
    if (defined(obj.topic)) {
      buf[offset++] = 10;
      enc[0].encode(obj.topic, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.mid)) {
      buf[offset++] = 18;
      enc[0].encode(obj.mid, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.mtime)) {
      buf[offset++] = 26;
      enc[0].encode(obj.mtime, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.mtype)) {
      buf[offset++] = 34;
      enc[0].encode(obj.mtype, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.subid)) {
      buf[offset++] = 40;
      enc[1].encode(obj.subid, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.msgcnt)) {
      buf[offset++] = 48;
      enc[1].encode(obj.msgcnt, buf, offset);
      offset += enc[1].encode.bytes;
    }
    if (defined(obj.mpoint)) {
      buf[offset++] = 58;
      enc[0].encode(obj.mpoint, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.msubtype)) {
      buf[offset++] = 66;
      enc[0].encode(obj.msubtype, buf, offset);
      offset += enc[0].encode.bytes;
    }
    if (defined(obj.notice_push_list)) {
      for (var i = 0; i < obj.notice_push_list.length; i++) {
        if (!defined(obj.notice_push_list[i])) continue;
        buf[offset++] = 74;
        varint.encode(
          enc[2].encodingLength(obj.notice_push_list[i]),
          buf,
          offset
        );
        offset += varint.encode.bytes;
        enc[2].encode(obj.notice_push_list[i], buf, offset);
        offset += enc[2].encode.bytes;
      }
    }
    if (defined(obj.data_change_event_list)) {
      for (var i = 0; i < obj.data_change_event_list.length; i++) {
        if (!defined(obj.data_change_event_list[i])) continue;
        buf[offset++] = 82;
        varint.encode(
          enc[3].encodingLength(obj.data_change_event_list[i]),
          buf,
          offset
        );
        offset += varint.encode.bytes;
        enc[3].encode(obj.data_change_event_list[i], buf, offset);
        offset += enc[3].encode.bytes;
      }
    }
    encode.bytes = offset - oldOffset;
    return buf;
  }

  function decode(buf, offset, end) {
    if (!offset) offset = 0;
    if (!end) end = buf.length;
    if (!(end <= buf.length && offset <= buf.length))
      throw new Error("Decoded message is not valid");
    var oldOffset = offset;
    var obj = {
      topic: "",
      mid: "",
      mtime: "",
      mtype: "",
      subid: 0,
      msgcnt: 0,
      mpoint: "",
      msubtype: "",
      notice_push_list: [],
      data_change_event_list: [],
    };
    while (true) {
      if (end <= offset) {
        decode.bytes = offset - oldOffset;
        return obj;
      }
      var prefix = varint.decode(buf, offset);
      offset += varint.decode.bytes;
      var tag = prefix >> 3;
      switch (tag) {
        case 1:
          obj.topic = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 2:
          obj.mid = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 3:
          obj.mtime = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 4:
          obj.mtype = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 5:
          obj.subid = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 6:
          obj.msgcnt = enc[1].decode(buf, offset);
          offset += enc[1].decode.bytes;
          break;
        case 7:
          obj.mpoint = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 8:
          obj.msubtype = enc[0].decode(buf, offset);
          offset += enc[0].decode.bytes;
          break;
        case 9:
          var len = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          obj.notice_push_list.push(enc[2].decode(buf, offset, offset + len));
          offset += enc[2].decode.bytes;
          break;
        case 10:
          var len = varint.decode(buf, offset);
          offset += varint.decode.bytes;
          obj.data_change_event_list.push(
            enc[3].decode(buf, offset, offset + len)
          );
          offset += enc[3].decode.bytes;
          break;
        default:
          offset = skip(prefix & 7, buf, offset);
      }
    }
  }
}

function defined(val) {
  return (
    val !== null &&
    val !== undefined &&
    (typeof val !== "number" || !Number.isNaN(val))
  );
}

